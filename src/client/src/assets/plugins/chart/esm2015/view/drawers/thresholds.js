import { Injectable } from '@angular/core';
import { BaseChartExtension } from '../../base/chart-base-extension';
import { AXIS_X, AXIS_Y_LEFT, AXIS_Y_RIGHT, ThresholdAxis, ThresholdColor, ThresholdOperator } from '../../chart.m';
import * as i0 from "@angular/core";
import * as i1 from "../../base/chart.store";
export class ThresholdDrawerPlugin extends BaseChartExtension {
    constructor(store) {
        super(store);
    }
    afterDatasetsDraw(chart, _) {
        var _a, _b;
        (_b = (_a = this
            .widget) === null || _a === void 0 ? void 0 : _a.display) === null || _b === void 0 ? void 0 : _b.thresholds.forEach(t => new ThresholdDrawer(chart, t).draw());
    }
}
ThresholdDrawerPlugin.ɵfac = function ThresholdDrawerPlugin_Factory(t) { return new (t || ThresholdDrawerPlugin)(i0.ɵɵinject(i1.ChartStore)); };
ThresholdDrawerPlugin.ɵprov = i0.ɵɵdefineInjectable({ token: ThresholdDrawerPlugin, factory: ThresholdDrawerPlugin.ɵfac });
/*@__PURE__*/ (function () { i0.ɵsetClassMetadata(ThresholdDrawerPlugin, [{
        type: Injectable
    }], function () { return [{ type: i1.ChartStore }]; }, null); })();
class ThresholdDrawer {
    constructor(chart, threshold) {
        this.chart = chart;
        this.threshold = threshold;
    }
    get context() {
        return this.chart.chart.ctx;
    }
    draw() {
        if (this.threshold.value == undefined) {
            return;
        }
        const scaleYA = this.chart.scales[AXIS_Y_LEFT];
        const scaleYB = this.chart.scales[AXIS_Y_RIGHT];
        const scaleX = this.chart.scales[AXIS_X];
        const scaleY = (this.threshold.axis == ThresholdAxis.Right && scaleYB) ?
            scaleYB : scaleYA;
        const offset = scaleY.getPixelForValue(this.threshold.value);
        const gt = (this.threshold.operator == ThresholdOperator.Gt);
        const shouldIgnore = (!gt && this.threshold.value < scaleY.min) ||
            (gt && this.threshold.value > scaleY.max) ||
            (!this.chart.data.datasets.length);
        if (shouldIgnore) {
            return;
        }
        // if( offset < 0 || offset > scaleY.bottom ){
        // 	return;
        // }
        //console.log( `${offset} | ${scaleY.bottom}` )  
        if (this.threshold.line) {
            const lineColor = this.getColor(false);
            this.renderLine(scaleX, lineColor, offset);
        }
        if (this.threshold.fill) {
            this.renderRectangle(scaleX, scaleY, offset);
        }
    }
    renderLine(scaleX, color, offset) {
        this.context.beginPath();
        this.context.strokeStyle = color + "99";
        this.context.lineWidth = 2;
        this.context.moveTo(scaleX.left, offset);
        this.context.lineTo(scaleX.right, offset);
        this.context.stroke();
    }
    renderRectangle(scaleX, scaleY, offset) {
        const color = this.getColor(true);
        const gt = (this.threshold.operator == ThresholdOperator.Gt);
        this.context.fillStyle = color + "22";
        const x = scaleX.left;
        const w = scaleX.width;
        const topY = scaleY.getPixelForValue(scaleY.max);
        const bottomY = scaleY.getPixelForValue(scaleY.min);
        const y = gt ? topY : Math.max(topY, offset);
        let h = gt ? offset - scaleY.top : scaleY.bottom - offset;
        h = Math.min(bottomY - topY, h);
        this.context.fillRect(x, y, w, h);
    }
    getColor(fill) {
        switch (this.threshold.colorType) {
            case ThresholdColor.Critical:
                return '#ED2E18';
            case ThresholdColor.Ok:
                return '#10a345';
            case ThresholdColor.Warning:
                return '#f79520';
        }
        const defaultColor = '#ffffff';
        if (fill) {
            return this.threshold.fillColor ? this.threshold.fillColor : defaultColor;
        }
        return this.threshold.lineColor ? this.threshold.lineColor : defaultColor;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhyZXNob2xkcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2FwcC9wbHVnaW5zL3dpZGdldHMvY2hhcnQvc3JjL3ZpZXcvZHJhd2Vycy90aHJlc2hvbGRzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFckUsT0FBTyxFQUFFLE1BQU0sRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUN6QyxhQUFhLEVBQUUsY0FBYyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDOzs7QUFHekUsTUFBTSxPQUFPLHFCQUFzQixTQUFRLGtCQUFrQjtJQUU1RCxZQUFhLEtBQWlCO1FBQzdCLEtBQUssQ0FBRSxLQUFLLENBQUUsQ0FBQztJQUNoQixDQUFDO0lBRUQsaUJBQWlCLENBQUMsS0FBSyxFQUFFLENBQUM7O1FBQ3pCLFlBQUEsSUFBSTthQUNGLE1BQU0sMENBQ0wsT0FBTywwQ0FDUCxVQUFVLENBQ1gsT0FBTyxDQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxlQUFlLENBQUUsS0FBSyxFQUFFLENBQUMsQ0FBRSxDQUFDLElBQUksRUFBRSxFQUFHO0lBQzFELENBQUM7OzBGQVpXLHFCQUFxQjs2REFBckIscUJBQXFCLFdBQXJCLHFCQUFxQjtrREFBckIscUJBQXFCO2NBRGpDLFVBQVU7O0FBZ0JYLE1BQU0sZUFBZTtJQUtwQixZQUFxQixLQUFVLEVBQVUsU0FBb0I7UUFBeEMsVUFBSyxHQUFMLEtBQUssQ0FBSztRQUFVLGNBQVMsR0FBVCxTQUFTLENBQVc7SUFFN0QsQ0FBQztJQU5ELElBQUksT0FBTztRQUNWLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO0lBQzdCLENBQUM7SUFNRCxJQUFJO1FBQ0gsSUFBSSxJQUFJLENBQUMs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Q0FBQztTQUMxRTtRQUVELE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUM7SUFDM0UsQ0FBQztDQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBCYXNlQ2hhcnRFeHRlbnNpb24gfSBmcm9tICcuLi8uLi9iYXNlL2NoYXJ0LWJhc2UtZXh0ZW5zaW9uJztcclxuaW1wb3J0IHsgQ2hhcnRTdG9yZSB9IGZyb20gJy4uLy4uL2Jhc2UvY2hhcnQuc3RvcmUnO1xyXG5pbXBvcnQgeyBBWElTX1gsIEFYSVNfWV9MRUZULCBBWElTX1lfUklHSFQsIFRocmVzaG9sZCxcclxuXHRUaHJlc2hvbGRBeGlzLCBUaHJlc2hvbGRDb2xvciwgVGhyZXNob2xkT3BlcmF0b3IgfSBmcm9tICcuLi8uLi9jaGFydC5tJztcclxuXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFRocmVzaG9sZERyYXdlclBsdWdpbiBleHRlbmRzIEJhc2VDaGFydEV4dGVuc2lvbiB7XHJcblx0XHJcblx0Y29uc3RydWN0b3IoIHN0b3JlOiBDaGFydFN0b3JlICl7XHJcblx0XHRzdXBlciggc3RvcmUgKTtcclxuXHR9XHJcblxyXG5cdGFmdGVyRGF0YXNldHNEcmF3KGNoYXJ0LCBfKSB7XHJcblx0XHR0aGlzXHJcblx0XHRcdC53aWRnZXRcclxuXHRcdFx0Py5kaXNwbGF5XHJcblx0XHRcdD8udGhyZXNob2xkc1xyXG5cdFx0XHQuZm9yRWFjaCggdCA9PiBuZXcgVGhyZXNob2xkRHJhd2VyKCBjaGFydCwgdCApLmRyYXcoKSApO1xyXG5cdH1cclxufVxyXG5cclxuY2xhc3MgVGhyZXNob2xkRHJhd2Vye1xyXG5cdGdldCBjb250ZXh0KCl7XHJcblx0XHRyZXR1cm4gdGhpcy5jaGFydC5jaGFydC5jdHg7XHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggcHJpdmF0ZSBjaGFydDogYW55LCBwcml2YXRlIHRocmVzaG9sZDogVGhyZXNob2xkICl7XHJcblx0XHRcclxuXHR9XHJcblxyXG5cdGRyYXcoKXtcclxuXHRcdGlmKCB0aGlzLnRocmVzaG9sZC52YWx1ZSA9PSB1bmRlZmluZWQgKXtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNvbnN0IHNjYWxlWUEgPSB0aGlzLmNoYXJ0LnNjYWxlc1sgQVhJU19ZX0xFRlQgXTtcclxuXHRcdGNvbnN0IHNjYWxlWUIgPSB0aGlzLmNoYXJ0LnNjYWxlc1sgQVhJU19ZX1JJR0hUIF07XHJcblx0XHRjb25zdCBzY2FsZVggPSB0aGlzLmNoYXJ0LnNjYWxlc1sgQVhJU19YIF07XHJcblxyXG5cdFx0Y29uc3Qgc2NhbGVZID0gKCB0aGlzLnRocmVzaG9sZC5heGlzID09IFRocmVzaG9sZEF4aXMuUmlnaHQgJiYgc2NhbGVZQiApID9cclxuXHRcdFx0c2NhbGVZQiA6IHNjYWxlWUE7XHJcblxyXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gc2NhbGVZLmdldFBpeGVsRm9yVmFsdWUodGhpcy50aHJlc2hvbGQudmFsdWUpO1xyXG5cclxuXHRcdGNvbnN0IGd0ID0gKCB0aGlzLnRocmVzaG9sZC5vcGVyYXRvciA9PSBUaHJlc2hvbGRPcGVyYXRvci5HdCApO1xyXG5cclxuXHRcdGNvbnN0IHNob3VsZElnbm9yZSA9IFxyXG5cdFx0XHQoICFndCAmJiB0aGlzLnRocmVzaG9sZC52YWx1ZSA8IHNjYWxlWS5taW4gKSB8fFxyXG5cdFx0XHQoIGd0ICYmIHRoaXMudGhyZXNob2xkLnZhbHVlID4gc2NhbGVZLm1heCApIHx8XHJcblx0XHRcdCggIXRoaXMuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGggKTtcclxuXHJcblx0XHRpZiggc2hvdWxkSWdub3JlICl7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBpZiggb2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBzY2FsZVkuYm90dG9tICl7XHJcblx0XHQvLyBcdHJldHVybjtcclxuXHRcdC8vIH1cclxuXHJcblx0XHQvL2NvbnNvbGUubG9nKCBgJHtvZmZzZXR9IHwgJHtzY2FsZVkuYm90dG9tfWAgKSAgXHJcblxyXG5cdFx0aWYoIHRoaXMudGhyZXNob2xkLmxpbmUgKXtcclxuXHRcdFx0Y29uc3QgbGluZUNvbG9yID0gdGhpcy5nZXRDb2xvciggZmFsc2UgKTtcclxuXHRcdFx0dGhpcy5yZW5kZXJMaW5lKCBzY2FsZVgsIGxpbmVDb2xvciwgb2Zmc2V0ICk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIHRoaXMudGhyZXNob2xkLmZpbGwgKXtcclxuXHRcdFx0dGhpcy5yZW5kZXJSZWN0YW5nbGUoIHNjYWxlWCwgc2NhbGVZLCBvZmZzZXQgKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVuZGVyTGluZShzY2FsZVgsIGNvbG9yLCBvZmZzZXQgKXtcclxuXHRcdHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcclxuXHRcdHRoaXMuY29udGV4dC5zdHJva2VTdHlsZSA9IGNvbG9yICsgXCI5OVwiO1xyXG5cdFx0dGhpcy5jb250ZXh0LmxpbmVXaWR0aCA9IDI7XHJcblx0XHR0aGlzLmNvbnRleHQubW92ZVRvKCBzY2FsZVgubGVmdCwgb2Zmc2V0KTtcclxuXHRcdHRoaXMuY29udGV4dC5saW5lVG8oIHNjYWxlWC5yaWdodCwgb2Zmc2V0KTtcclxuXHRcdHRoaXMuY29udGV4dC5zdHJva2UoKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgcmVuZGVyUmVjdGFuZ2xlKCBzY2FsZVgsIHNjYWxlWSwgb2Zmc2V0ICl7XHJcblx0XHRjb25zdCBjb2xvciA9IHRoaXMuZ2V0Q29sb3IoIHRydWUgKTtcclxuXHJcblx0XHRjb25zdCBndCA9ICggdGhpcy50aHJlc2hvbGQub3BlcmF0b3IgPT0gVGhyZXNob2xkT3BlcmF0b3IuR3QgKTtcclxuXHRcdHRoaXMuY29udGV4dC5maWxsU3R5bGUgPSBjb2xvciArIFwiMjJcIlxyXG5cclxuXHRcdGNvbnN0IHggPSBzY2FsZVgubGVmdDtcclxuXHRcdGNvbnN0IHcgPSBzY2FsZVgud2lkdGg7XHJcblxyXG5cdFx0Y29uc3QgdG9wWSA9IHNjYWxlWS5nZXRQaXhlbEZvclZhbHVlKHNjYWxlWS5tYXgpO1xyXG5cdFx0Y29uc3QgYm90dG9tWSA9IHNjYWxlWS5nZXRQaXhlbEZvclZhbHVlKHNjYWxlWS5taW4pO1xyXG5cclxuXHRcdGNvbnN0IHkgPSBndCA/IHRvcFkgOiBNYXRoLm1heCggdG9wWSwgb2Zmc2V0ICk7XHJcblx0XHRsZXQgaCA9IGd0ID8gb2Zmc2V0IC0gc2NhbGVZLnRvcCA6IHNjYWxlWS5ib3R0b20gLSBvZmZzZXQ7XHJcblxyXG5cdFx0aCA9IE1hdGgubWluKCBib3R0b21ZIC0gdG9wWSwgaCApXHJcblxyXG5cdFx0dGhpcy5jb250ZXh0LmZpbGxSZWN0KCB4LCB5LFx0dywgaCApO1x0XHJcblx0fVxyXG5cclxuXHRwcml2YXRlIGdldENvbG9yKGZpbGwpe1xyXG5cdFx0c3dpdGNoKCB0aGlzLnRocmVzaG9sZC5jb2xvclR5cGUgKXtcclxuXHRcdFx0Y2FzZSBUaHJlc2hvbGRDb2xvci5Dcml0aWNhbDpcclxuXHRcdFx0XHRyZXR1cm4gJyNFRDJFMTgnO1xyXG5cclxuXHRcdFx0Y2FzZSBUaHJlc2hvbGRDb2xvci5PazpcclxuXHRcdFx0XHRyZXR1cm4gJyMxMGEzNDUnO1xyXG5cclxuXHRcdFx0Y2FzZSBUaHJlc2hvbGRDb2xvci5XYXJuaW5nOlxyXG5cdFx0XHRcdHJldHVybiAnI2Y3OTUyMCc7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgZGVmYXVsdENvbG9yID0gJyNmZmZmZmYnO1xyXG5cclxuXHRcdGlmKCBmaWxsICl7XHJcblx0XHRcdHJldHVybiB0aGlzLnRocmVzaG9sZC5maWxsQ29sb3IgPyB0aGlzLnRocmVzaG9sZC5maWxsQ29sb3IgOiBkZWZhdWx0Q29sb3I7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudGhyZXNob2xkLmxpbmVDb2xvciA/IHRoaXMudGhyZXNob2xkLmxpbmVDb2xvciA6IGRlZmF1bHRDb2xvcjtcclxuXHR9XHJcbn0iXX0=