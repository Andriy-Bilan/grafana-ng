import { Moment } from 'common';
import { AXIS_Y_LEFT, TooltipSortOrder } from '../../chart.m';
import { ColorHelper } from 'uilib';
import { AxisUnitHelper } from '../../edit/axes/y-axis/unit-helper';
export class TooltipBuilder {
    constructor(model, component) {
        this.model = model;
        this.component = component;
        this.ID = "chartjs-tooltip";
        this.TOOLTIP_SELECTOR = "ed-tooltip";
    }
    static build(comp) {
        Chart.Tooltip.positioners.custom = (_, event) => {
            return {
                x: event.x,
                y: event.y
            };
        };
        return {
            mode: 'index',
            position: "custom",
            axis: 'x',
            intersect: false,
            caretSize: 0,
            xPadding: 10,
            bodySpacing: 5,
            titleAlign: 'right',
            enabled: false,
            custom: (model) => new TooltipBuilder(model, comp).create()
        };
    }
    get root() {
        var tooltipEl = document.getElementById(this.ID);
        // Create element on first render
        if (!tooltipEl) {
            tooltipEl = document.createElement('div');
            tooltipEl.id = this.ID;
            tooltipEl.innerHTML = `<div class='graph-tooltip grafana-tooltip ${this.TOOLTIP_SELECTOR}'></div>`;
            document.body.appendChild(tooltipEl);
        }
        return tooltipEl;
    }
    create() {
        var tooltipElement = this.root;
        // Hide if no tooltip
        if (this.model.opacity === 0 || this.component.nativeControl.showAnnotView) {
            tooltipElement.style.opacity = '0';
            return;
        }
        tooltipElement.classList.remove('above', 'below', 'no-transform');
        if (this.model.yAlign) {
            tooltipElement.classList.add(this.model.yAlign);
        }
        else {
            tooltipElement.classList.add('no-transform');
        }
        if (this.model.body) {
            this.createBody();
        }
        this.setPosition();
    }
    setPosition() {
        var tooltipElement = this.root;
        const chart = this.component.control.chart;
        var position = chart
            .canvas
            .getBoundingClientRect();
        const elWidth = document
            .getElementsByClassName(this.TOOLTIP_SELECTOR)[0]
            .getBoundingClientRect()
            .width;
        const negMargin = (this.model.caretX + elWidth > position.width) ?
            elWidth + 2 * this.model.xPadding : 0;
        tooltipElement.style.opacity = '1';
        tooltipElement.style.position = 'absolute';
        tooltipElement.style.left = position.left + window.pageXOffset + this.model.caretX - negMargin + 'px';
        tooltipElement.style.top = position.top + window.pageYOffset + this.model.caretY + 'px';
        tooltipElement.style.fontFamily = this.model._bodyFontFamily;
        tooltipElement.style.padding = this.model.yPadding + 'px ' + this.model.xPadding + 'px';
        tooltipElement.style.pointerEvents = 'none';
    }
    createBody() {
        var tooltipElement = this.root;
        var chart = this.component;
        var w = this.component.store.panel.widget;
        var titleLines = this.model.title || [];
        var innerHtml = '';
        titleLines.forEach(function (title) {
            const date = Date.parse(title);
            const time = Moment.format(date);
            innerHtml += `<div class="graph-tooltip-time">${time}</div>`;
        });
        const parsedBodyLines = this.sort();
        parsedBodyLines.forEach((body, i) => {
            const { seriesName, value, color } = body;
            let seriesNameEl = `
				<div class="graph-tooltip-series-name">
					<i class="fa fa-minus" style="color:${color};"></i> ${seriesName}:
				</div>`;
            const ds = chart
                .data
                .datasets
                .find(x => x.label == seriesName);
            const axis = (ds.yAxisID == AXIS_Y_LEFT) ? w.axes.leftY : w.axes.rightY;
            const decimals = w.legend.decimals ? w.legend.decimals : 1;
            const resValue = AxisUnitHelper.getFormattedValue(value, axis.unit, decimals);
            let valueEl = `<div class="graph-tooltip-value ">${resValue}</div>`;
            let item = `
				<div class="graph-tooltip-list-item">
					${seriesNameEl}
					${valueEl}
				</div>`;
            innerHtml += item;
        });
        var tableRoot = tooltipElement.querySelector(`.${this.TOOLTIP_SELECTOR}`);
        tableRoot.innerHTML = innerHtml;
    }
    sort() {
        function getBody(bodyItem) {
            return bodyItem.lines;
        }
        var bodyLines = this.model.body.map(getBody);
        const sortOrder = this
            .component
            .widget
            .display
            .tooltipSortOrder;
        const parsedBodyLines = [];
        bodyLines.forEach((body, i) => {
            var colors = this.model.labelColors[i];
            var color = ColorHelper.hexToRgbString(colors.backgroundColor);
            let index = body[0].lastIndexOf(':');
            const seriesName = body[0].substring(0, index);
            const value = parseFloat(this.model.dataPoints[i].value);
            parsedBodyLines.push({ seriesName, value, color });
        });
        switch (sortOrder) {
            case TooltipSortOrder.Increasing:
                parsedBodyLines.sort((a, b) => a.value - b.value);
                break;
            case TooltipSortOrder.Decreasing:
                parsedBodyLines.sort((a, b) => b.value - a.value);
                break;
        }
        const res = parsedBodyLines.filter(x => {
            var _a;
            return !((_a = this
                .component
                .display
                .getOverrideByLabel(x.seriesName)) === null || _a === void 0 ? void 0 : _a.hideInTooltip);
        });
        return res;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9vbHRpcC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL2FwcC9wbHVnaW5zL3dpZGdldHMvY2hhcnQvc3JjL3ZpZXcvZHJhd2Vycy90b29sdGlwLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxRQUFRLENBQUM7QUFFaEMsT0FBTyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUM5RCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sT0FBTyxDQUFDO0FBQ3BDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUlwRSxNQUFNLE9BQU8sY0FBYztJQTJDMUIsWUFBcUIsS0FBSyxFQUFVLFNBQXlCO1FBQXhDLFVBQUssR0FBTCxLQUFLLENBQUE7UUFBVSxjQUFTLEdBQVQsU0FBUyxDQUFnQjtRQXpDcEQsT0FBRSxHQUFHLGlCQUFpQixDQUFDO1FBQ3ZCLHFCQUFnQixHQUFHLFlBQVksQ0FBQztJQTBDekMsQ0FBQztJQXhDRCxNQUFNLENBQUMsS0FBSyxDQUFFLElBQW9CO1FBQ2pDLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsRUFBRTtZQUMvQyxPQUFPO2dCQUNOLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztnQkFDVixDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUM7YUFDVixDQUFDO1FBQ0gsQ0FBQyxDQUFDO1FBRUYsT0FBTztZQUNOLElBQUksRUFBRSxPQUFPO1lBQ2IsUUFBUSxFQUFFLFFBQVE7WUFDbEIsSUFBSSxFQUFFLEdBQUc7WUFDVCxTQUFTLEVBQUUsS0FBSztZQUNoQixTQUFTLEVBQUUsQ0FBQztZQUNaLFFBQVEsRUFBRSxFQUFFO1lBQ1osV0FBVyxFQUFFLENBQUM7WUFDZCxVQUFVLEVBQUUsT0FBTztZQUNuQixPQUFPLEVBQUUs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Q0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQ25ELE1BQU07U0FDUDtRQUdELE1BQU0sR0FBRyxHQUFHLGVBQWUsQ0FBQyxNQUFNLENBQUUsQ0FBQyxDQUFDLEVBQUU7O1lBQ3ZDLE9BQU8sUUFBQyxJQUFJO2lCQUNWLFNBQVM7aUJBQ1QsT0FBTztpQkFDUCxrQkFBa0IsQ0FBRSxDQUFDLENBQUMsVUFBVSxDQUFFLDBDQUNqQyxhQUFhLENBQUEsQ0FBQztRQUNsQixDQUFDLENBQUUsQ0FBQTtRQUVILE9BQU8sR0FBRyxDQUFDO0lBQ1osQ0FBQztDQUNEIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTW9tZW50IH0gZnJvbSAnY29tbW9uJztcclxuaW1wb3J0IHsgQ2hhcnRDb21wb25lbnQgfSBmcm9tICcuLi8uLi9jaGFydC5jJztcclxuaW1wb3J0IHsgQVhJU19ZX0xFRlQsIFRvb2x0aXBTb3J0T3JkZXIgfSBmcm9tICcuLi8uLi9jaGFydC5tJztcclxuaW1wb3J0IHsgQ29sb3JIZWxwZXIgfSBmcm9tICd1aWxpYic7XHJcbmltcG9ydCB7IEF4aXNVbml0SGVscGVyIH0gZnJvbSAnLi4vLi4vZWRpdC9heGVzL3ktYXhpcy91bml0LWhlbHBlcic7XHJcblxyXG5kZWNsYXJlIHZhciBDaGFydDogYW55O1xyXG5cclxuZXhwb3J0IGNsYXNzIFRvb2x0aXBCdWlsZGVyIHtcclxuXHJcblx0cmVhZG9ubHkgSUQgPSBcImNoYXJ0anMtdG9vbHRpcFwiO1xyXG5cdHJlYWRvbmx5IFRPT0xUSVBfU0VMRUNUT1IgPSBcImVkLXRvb2x0aXBcIjtcclxuXHJcblx0c3RhdGljIGJ1aWxkKCBjb21wOiBDaGFydENvbXBvbmVudCApe1xyXG5cdFx0Q2hhcnQuVG9vbHRpcC5wb3NpdGlvbmVycy5jdXN0b20gPSAoXywgZXZlbnQpID0+IHtcclxuXHRcdFx0cmV0dXJuIHtcclxuXHRcdFx0XHR4OiBldmVudC54LFxyXG5cdFx0XHRcdHk6IGV2ZW50LnlcclxuXHRcdFx0fTtcclxuXHRcdH07XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0bW9kZTogJ2luZGV4JyxcclxuXHRcdFx0cG9zaXRpb246IFwiY3VzdG9tXCIsXHJcblx0XHRcdGF4aXM6ICd4JyxcclxuXHRcdFx0aW50ZXJzZWN0OiBmYWxzZSxcclxuXHRcdFx0Y2FyZXRTaXplOiAwLFxyXG5cdFx0XHR4UGFkZGluZzogMTAsXHJcblx0XHRcdGJvZHlTcGFjaW5nOiA1LFxyXG5cdFx0XHR0aXRsZUFsaWduOiAncmlnaHQnLFxyXG5cdFx0XHRlbmFibGVkOiBmYWxzZSxcclxuXHRcdFx0Y3VzdG9tOiAoIG1vZGVsICkgPT4gbmV3IFRvb2x0aXBCdWlsZGVyKCBtb2RlbCwgY29tcCApLmNyZWF0ZSgpXHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRnZXQgcm9vdCgpe1xyXG5cdFx0dmFyIHRvb2x0aXBFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuSUQpO1xyXG5cclxuXHRcdC8vIENyZWF0ZSBlbGVtZW50IG9uIGZpcnN0IHJlbmRlclxyXG5cdFx0aWYoIXRvb2x0aXBFbCkge1xyXG5cdFx0XHR0b29sdGlwRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuXHRcdFx0dG9vbHRpcEVsLmlkID0gdGhpcy5JRDtcclxuXHJcblx0XHRcdHRvb2x0aXBFbC5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz0nZ3JhcGgtdG9vbHRpcCBncmFmYW5hLXRvb2x0aXAgJHt0aGlzLlRPT0xUSVBfU0VMRUNUT1J9Jz48L2Rpdj5gO1xyXG5cclxuXHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0b29sdGlwRWwpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0b29sdGlwRWw7XHJcblx0fVxyXG5cclxuXHRjb25zdHJ1Y3RvciggcHJpdmF0ZSBtb2RlbCwgcHJpdmF0ZSBjb21wb25lbnQ6IENoYXJ0Q29tcG9uZW50ICl7XHJcblxyXG5cdH1cclxuXHJcblx0Y3JlYXRlKCl7XHJcblx0XHR2YXIgdG9vbHRpcEVsZW1lbnQgPSB0aGlzLnJvb3Q7XHJcblxyXG5cdFx0Ly8gSGlkZSBpZiBubyB0b29sdGlwXHJcblx0XHRpZiggdGhpcy5tb2RlbC5vcGFjaXR5ID09PSAwIHx8IHRoaXMuY29tcG9uZW50Lm5hdGl2ZUNvbnRyb2wuc2hvd0Fubm90VmlldyApIHtcclxuXHRcdFx0dG9vbHRpcEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcwJztcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRvb2x0aXBFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2Fib3ZlJywgJ2JlbG93JywgJ25vLXRyYW5zZm9ybScpO1xyXG5cdFx0XHJcblx0XHRpZiAodGhpcy5tb2RlbC55QWxpZ24pIHtcclxuXHRcdFx0dG9vbHRpcEVsZW1lbnQuY2xhc3NMaXN0LmFkZCh0aGlzLm1vZGVsLnlBbGlnbik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0b29sdGlwRWxlbWVudC5jbGFzc0xpc3QuYWRkKCduby10cmFuc2Zvcm0nKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5tb2RlbC5ib2R5KSB7XHJcblx0XHRcdHRoaXMuY3JlYXRlQm9keSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc2V0UG9zaXRpb24oKTtcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgc2V0UG9zaXRpb24oKXtcclxuXHRcdHZhciB0b29sdGlwRWxlbWVudCA9IHRoaXMucm9vdDtcclxuXHRcdFxyXG5cdFx0Y29uc3QgY2hhcnQgPSB0aGlzLmNvbXBvbmVudC5jb250cm9sLmNoYXJ0O1xyXG5cclxuXHRcdHZhciBwb3NpdGlvbiA9IGNoYXJ0XHJcblx0XHRcdC5jYW52YXNcclxuXHRcdFx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHRcdGNvbnN0IGVsV2lkdGggPSBkb2N1bWVudFxyXG5cdFx0XHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSh0aGlzLlRPT0xUSVBfU0VMRUNUT1IpWyAwIF1cclxuXHRcdFx0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXHJcblx0XHRcdC53aWR0aDtcclxuXHJcblx0XHRjb25zdCBuZWdNYXJnaW4gPSAoIHRoaXMubW9kZWwuY2FyZXRYICsgZWxXaWR0aCA+IHBvc2l0aW9uLndpZHRoICkgP1xyXG5cdFx0XHRlbFdpZHRoICsgIDIgKiB0aGlzLm1vZGVsLnhQYWRkaW5nIDogMDtcclxuXHRcdFxyXG5cdFx0dG9vbHRpcEVsZW1lbnQuc3R5bGUub3BhY2l0eSA9ICcxJztcclxuXHRcdHRvb2x0aXBFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuXHRcdHRvb2x0aXBFbGVtZW50LnN0eWxlLmxlZnQgPSBwb3NpdGlvbi5sZWZ0ICsgd2luZG93LnBhZ2VYT2Zmc2V0ICsgdGhpcy5tb2RlbC5jYXJldFggLSBuZWdNYXJnaW4gKyAncHgnO1xyXG5cdFx0dG9vbHRpcEVsZW1lbnQuc3R5bGUudG9wID0gcG9zaXRpb24udG9wICsgd2luZG93LnBhZ2VZT2Zmc2V0ICsgdGhpcy5tb2RlbC5jYXJldFkgKyAncHgnO1xyXG5cdFx0dG9vbHRpcEVsZW1lbnQuc3R5bGUuZm9udEZhbWlseSA9IHRoaXMubW9kZWwuX2JvZHlGb250RmFtaWx5O1xyXG5cdFx0dG9vbHRpcEVsZW1lbnQuc3R5bGUucGFkZGluZyA9IHRoaXMubW9kZWwueVBhZGRpbmcgKyAncHggJyArIHRoaXMubW9kZWwueFBhZGRpbmcgKyAncHgnO1xyXG5cdFx0dG9vbHRpcEVsZW1lbnQuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcclxuXHR9XHJcblxyXG5cdHByaXZhdGUgY3JlYXRlQm9keSgpe1xyXG5cdFx0dmFyIHRvb2x0aXBFbGVtZW50ID0gdGhpcy5yb290O1xyXG5cdFx0dmFyIGNoYXJ0ID0gdGhpcy5jb21wb25lbnQ7XHJcblx0XHR2YXIgdyA9IHRoaXMuY29tcG9uZW50LnN0b3JlLnBhbmVsLndpZGdldDtcclxuXHJcblx0XHR2YXIgdGl0bGVMaW5lcyA9IHRoaXMubW9kZWwudGl0bGUgfHwgW107XHJcblx0XHR2YXIgaW5uZXJIdG1sID0gJyc7XHJcblxyXG5cdFx0dGl0bGVMaW5lcy5mb3JFYWNoKGZ1bmN0aW9uKHRpdGxlKSB7XHJcblx0XHRcdGNvbnN0IGRhdGUgPSBEYXRlLnBhcnNlKCB0aXRsZSApO1xyXG5cdFx0XHRjb25zdCB0aW1lID0gTW9tZW50LmZvcm1hdCAoIGRhdGUgKTtcclxuXHRcdFx0aW5uZXJIdG1sICs9IGA8ZGl2IGNsYXNzPVwiZ3JhcGgtdG9vbHRpcC10aW1lXCI+JHt0aW1lfTwvZGl2PmBcclxuXHRcdH0pO1xyXG5cclxuXHRcdGNvbnN0IHBhcnNlZEJvZHlMaW5lcyA9IHRoaXMuc29ydCgpO1xyXG5cclxuXHRcdHBhcnNlZEJvZHlMaW5lcy5mb3JFYWNoKCAoYm9keSwgaSkgPT4ge1xyXG5cdFx0XHRjb25zdCB7IHNlcmllc05hbWUsIHZhbHVlLCBjb2xvciB9ID0gYm9keTtcclxuXHJcblx0XHRcdGxldCBzZXJpZXNOYW1lRWwgPSBgXHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cImdyYXBoLXRvb2x0aXAtc2VyaWVzLW5hbWVcIj5cclxuXHRcdFx0XHRcdDxpIGNsYXNzPVwiZmEgZmEtbWludXNcIiBzdHlsZT1cImNvbG9yOiR7Y29sb3J9O1wiPjwvaT4gJHtzZXJpZXNOYW1lfTpcclxuXHRcdFx0XHQ8L2Rpdj5gXHJcblxyXG5cdFx0XHRjb25zdCBkcyA9IGNoYXJ0XHJcblx0XHRcdFx0LmRhdGFcclxuXHRcdFx0XHQuZGF0YXNldHNcclxuXHRcdFx0XHQuZmluZCggeCA9PiB4LmxhYmVsID09IHNlcmllc05hbWUgKTtcclxuXHJcblx0XHRcdGNvbnN0IGF4aXMgPSAgICggZHMueUF4aXNJRCA9PSBBWElTX1lfTEVGVCApID9cdHcuYXhlcy5sZWZ0WSA6IHcuYXhlcy5yaWdodFk7XHJcblxyXG5cdFx0XHRjb25zdCBkZWNpbWFscyA9IHcubGVnZW5kLmRlY2ltYWxzID8gdy5sZWdlbmQuZGVjaW1hbHMgOiAxO1xyXG5cclxuXHRcdFx0Y29uc3QgcmVzVmFsdWUgPSBBeGlzVW5pdEhlbHBlci5nZXRGb3JtYXR0ZWRWYWx1ZSggdmFsdWUsIGF4aXMudW5pdCwgZGVjaW1hbHMgKVxyXG5cclxuXHRcdFx0bGV0IHZhbHVlRWwgPSBgPGRpdiBjbGFzcz1cImdyYXBoLXRvb2x0aXAtdmFsdWUgXCI+JHtyZXNWYWx1ZX08L2Rpdj5gO1xyXG5cclxuXHRcdFx0bGV0IGl0ZW0gPSBgXHJcblx0XHRcdFx0PGRpdiBjbGFzcz1cImdyYXBoLXRvb2x0aXAtbGlzdC1pdGVtXCI+XHJcblx0XHRcdFx0XHQke3Nlcmllc05hbWVFbH1cclxuXHRcdFx0XHRcdCR7dmFsdWVFbH1cclxuXHRcdFx0XHQ8L2Rpdj5gXHJcblxyXG5cdFx0XHRpbm5lckh0bWwgKz0gaXRlbTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciB0YWJsZVJvb3QgPSB0b29sdGlwRWxlbWVudC5xdWVyeVNlbGVjdG9yKGAuJHt0aGlzLlRPT0xUSVBfU0VMRUNUT1J9YCk7XHJcblx0XHR0YWJsZVJvb3QuaW5uZXJIVE1MID0gaW5uZXJIdG1sO1xyXG5cdH1cclxuXHJcblx0cHJpdmF0ZSBzb3J0KCkgOiBBcnJheTxhbnk+e1xyXG5cdFx0ZnVuY3Rpb24gZ2V0Qm9keShib2R5SXRlbSkge1xyXG5cdFx0XHRyZXR1cm4gYm9keUl0ZW0ubGluZXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGJvZHlMaW5lcyA9IHRoaXMubW9kZWwuYm9keS5tYXAoZ2V0Qm9keSk7XHJcblxyXG5cdFx0Y29uc3Qgc29ydE9yZGVyID0gdGhpc1xyXG5cdFx0XHQuY29tcG9uZW50XHJcblx0XHRcdC53aWRnZXRcclxuXHRcdFx0LmRpc3BsYXlcclxuXHRcdFx0LnRvb2x0aXBTb3J0T3JkZXI7XHJcblxyXG5cdFx0Y29uc3QgcGFyc2VkQm9keUxpbmVzID0gW107XHJcblx0XHRcclxuXHRcdGJvZHlMaW5lcy5mb3JFYWNoKChib2R5LCBpKSA9PiB7XHJcblx0XHRcdHZhciBjb2xvcnMgPSB0aGlzLm1vZGVsLmxhYmVsQ29sb3JzWyBpIF07XHJcblx0XHRcdHZhciBjb2xvciA9IENvbG9ySGVscGVyLmhleFRvUmdiU3RyaW5nKCBjb2xvcnMuYmFja2dyb3VuZENvbG9yKTtcclxuXHJcblx0XHRcdGxldCBpbmRleCA9IGJvZHlbIDAgXS5sYXN0SW5kZXhPZiggJzonICk7XHJcblx0XHRcdGNvbnN0IHNlcmllc05hbWUgPSBib2R5WyAwIF0uc3Vic3RyaW5nKCAwLCBpbmRleCApO1xyXG5cdFx0XHRjb25zdCB2YWx1ZSA9IHBhcnNlRmxvYXQodGhpcy5tb2RlbC5kYXRhUG9pbnRzWyBpIF0udmFsdWUpO1xyXG5cdFx0XHRwYXJzZWRCb2R5TGluZXMucHVzaCgge3Nlcmllc05hbWUsIHZhbHVlLCBjb2xvcn0gKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHN3aXRjaCggc29ydE9yZGVyICl7XHJcblx0XHRcdGNhc2UgVG9vbHRpcFNvcnRPcmRlci5JbmNyZWFzaW5nOlxyXG5cdFx0XHRcdHBhcnNlZEJvZHlMaW5lcy5zb3J0KCAoYSwgYikgPT4gYS52YWx1ZSAtIGIudmFsdWUpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSBUb29sdGlwU29ydE9yZGVyLkRlY3JlYXNpbmc6XHJcblx0XHRcdFx0cGFyc2VkQm9keUxpbmVzLnNvcnQoIChhLCBiKSA9PiBiLnZhbHVlIC0gYS52YWx1ZSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdGNvbnN0IHJlcyA9IHBhcnNlZEJvZHlMaW5lcy5maWx0ZXIoIHggPT4ge1xyXG5cdFx0XHRyZXR1cm4gIXRoaXNcclxuXHRcdFx0XHQuY29tcG9uZW50XHJcblx0XHRcdFx0LmRpc3BsYXlcclxuXHRcdFx0XHQuZ2V0T3ZlcnJpZGVCeUxhYmVsKCB4LnNlcmllc05hbWUgKVxyXG5cdFx0XHRcdD8uaGlkZUluVG9vbHRpcDtcclxuXHRcdH0gKVxyXG5cclxuXHRcdHJldHVybiByZXM7XHJcblx0fVxyXG59XHJcblxyXG5cclxuIl19